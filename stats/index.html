<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Hopkins — Stats</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../main.css">
  <link rel="stylesheet" href="/stats/stats.css">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300..700;1,300..700&display=swap" rel="stylesheet">

  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
</head>
<body>
  <div id="main">
    <h1>Stats</h1>

    <!-- Chart -->
    <div id="chart-wrapper" role="region" aria-label="Poems per author">
        <div id="stats-controls">
            <label for="topN">Top</label>
            <input id="topN" type="range" min="5" max="30" value="10" step="1"/>
            <output id="topNvalue">10</output>
            <span>authors (by poem count). Use slider to show how many authors are shown.</span>
        </div>

        <canvas id="authorsChart" aria-label="Bar chart of poems per author"></canvas>
    
        <div id="no-data" style="display: none;">No stats data found — generate <code>stats/author_counts.json</code> first.</div>    
    </div>

    <!-- Table -->
    <div id="table-wrapper">
        <table id="authors-table" aria-describedby="authorsLegend">
            <thead>
                <tr><th>Author</th><th style="width:80px">Poems</th></tr>
            </thead>
            <tbody id="authors-body"></tbody>
        </table>
    </div>


    <p id="tagline">Built with <a href="https://github.com/fraile-tok/hopkins">Hopkins</a> by <a href="https://jpiglesias.github.io">JPIglesias</a></p>

  </div>

  <script>
    async function tryFetchAny(paths) {
        for (const p of paths) {
            try {
                const r = await fetch(p, {cache: "no-store"});
                if (r.ok) return await r.json();
            } catch (e) {}
        }
        return null;
    }

    (async function() {
        const preferPaths = [
            'author_counts.json',
            '/stats/author_counts.json'
        ];

        const data = await tryFetchAny(preferPaths);

        const noDataEl = document.getElementById('no-data');
        if (!data || !data.raw || !Array.isArray(data.raw) || data.raw.length === 0) {
            noDataEl.style.display = 'block';
            return;
        } else {
            noDataEl.style.display = 'none';
        }

        const raw = data.raw.slice();

        // Controls
        const topNSlider = document.getElementById('topN');
        const topNValue = document.getElementById('topNvalue');
        const tbody = document.getElementById('authors-body');

        topNSlider.addEventListener('input', () => {
            topNValue.textContent = topNSlider.value;
            updateChartAndTable();
        });

        // Chart
        let chart = null;
        const ctx = document.getElementById('authorsChart').getContext('2d');

        function buildDatasets(list) {
            const labels = list.map(d => d.author);
            const values = list.map(d => d.count);
            return { labels, values, raw: list };
        }

        function renderTable(list) {
            tbody.innerHTML = '';
            for (const r of list) {
                const tr = document.createElement('tr');
                const a = document.createElement('td');
                a.textContent = r.author;
                const b = document.createElement('td');
                b.textContent = r.count;
                tr.appendChild(a);
                tr.appendChild(b);
                tbody.appendChild(tr);
            }
        }

        function renderChart(list) {
            const ds = buildDatasets(list);

            if (chart) chart.destroy();

            chart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ds.labels,
                    datasets: [{
                        label: 'Poems',
                        data: ds.values,
                        borderWidth: 1,
                        hoverBorderWidth: 2
                    }]
                },
                options: {
                    maintainAspectRatio: false,
                    responsive: true,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                title: (items) => items[0].label,
                                label: (ctx) => `${ctx.formattedValue} poem${ctx.raw === 1 ? '' : 's'}`
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { autoSkip: false, maxRotation: 45, minRotation: 0 },
                            title: { display: false }
                        },
                        y: {
                            beginAtZero: true,
                            precision: 0,
                            ticks: { stepSize: 1 }
                        }
                    },
                    onClick: (evt, elements) => {
                        if (!elements.length) return;
                        const idx = elements[0].index;
                        const row = ds.raw[idx];
                    }
                }
            });
        }

        function updateChartAndTable() {
            const N = parseInt(topNSlider.value, 10) || 10;
            const sorted = raw.slice().sort((a,b) => b.count - a.count || a.author.localeCompare(b.author));
            const top = sorted.slice(0,N);
            renderChart(top);
            renderTable(top);
        }

        topNSlider.max = Math.max(5, raw.length);
        topNSlider.value = Math.min(10, raw.length);
        topNValue.textContent = topNSlider.value;
        
        // render
        updateChartAndTable();
     })();
  </script>
</body>
</html>